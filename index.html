<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Adventure 3D</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      touch-action: none;
    }

    #info {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-family: Arial, sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 6px 10px;
      border-radius: 6px;
      z-index: 10;
    }

    /* Joystick */
    #joystick {
      position: fixed;
      bottom: 40px;
      left: 40px;
      width: 120px;
      height: 120px;
      background: rgba(255,255,255,0.15);
      border-radius: 50%;
      z-index: 20;
      touch-action: none;
    }

    #stick {
      position: absolute;
      left: 35px;
      top: 35px;
      width: 50px;
      height: 50px;
      background: rgba(255,255,255,0.6);
      border-radius: 50%;
    }
  </style>
</head>
<body>

<div id="info">Joystick (mobile) â€¢ Arrow keys (desktop)</div>

<div id="joystick">
  <div id="stick"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
  /* ===== THREE.JS SETUP ===== */
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.set(0, 3, 6);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(5, 10, 5);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0xffffff, 0.4));

  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(100, 100),
    new THREE.MeshStandardMaterial({ color: 0x2e8b57 })
  );
  ground.rotation.x = -Math.PI / 2;
  scene.add(ground);

  const player = new THREE.Mesh(
    new THREE.BoxGeometry(1, 1, 1),
    new THREE.MeshStandardMaterial({ color: 0xffd700 })
  );
  player.position.y = 0.5;
  scene.add(player);

  /* ===== INPUT ===== */
  let moveX = 0;
  let moveZ = 0;

  const keys = {};
  window.addEventListener("keydown", e => keys[e.key] = true);
  window.addEventListener("keyup", e => keys[e.key] = false);

  /* ===== JOYSTICK LOGIC ===== */
  const joystick = document.getElementById("joystick");
  const stick = document.getElementById("stick");

  let dragging = false;
  const center = { x: 60, y: 60 };
  const maxDist = 40;

  joystick.addEventListener("touchstart", e => {
    dragging = true;
  });

  joystick.addEventListener("touchmove", e => {
    if (!dragging) return;
    const rect = joystick.getBoundingClientRect();
    const touch = e.touches[0];

    let x = touch.clientX - rect.left - center.x;
    let y = touch.clientY - rect.top - center.y;

    const dist = Math.min(Math.sqrt(x*x + y*y), maxDist);
    const angle = Math.atan2(y, x);

    x = Math.cos(angle) * dist;
    y = Math.sin(angle) * dist;

    stick.style.left = (center.x + x - 25) + "px";
    stick.style.top  = (center.y + y - 25) + "px";

    moveX = x / maxDist * 0.12;
    moveZ = y / maxDist * 0.12;
  });

  joystick.addEventListener("touchend", () => {
    dragging = false;
    stick.style.left = "35px";
    stick.style.top  = "35px";
    moveX = 0;
    moveZ = 0;
  });

  /* ===== LOOP ===== */
  function animate() {
    requestAnimationFrame(animate);

    // Desktop controls
    if (keys["ArrowUp"]) moveZ = -0.12;
    if (keys["ArrowDown"]) moveZ = 0.12;
    if (keys["ArrowLeft"]) moveX = -0.12;
    if (keys["ArrowRight"]) moveX = 0.12;

    player.position.x += moveX;
    player.position.z += moveZ;

    camera.position.x = player.position.x;
    camera.position.z = player.position.z + 6;
    camera.lookAt(player.position);

    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>
