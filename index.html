    <script>
// ================ MOBILE PLANET EMPIRE BUILDER ================

// Game State
const gameState = {
    resources: {
        wood: 0,
        wheat: 0,
        stone: 0,
        gold: 0,
        bread: 0
    },
    player: {
        health: 100,
        position: new THREE.Vector3(0, 0, 0)
    },
    currentTool: 'axe',
    buildings: []
};

// Three.js Variables
let scene, camera, renderer;
let planet;
let trees = [], rocks = [], wheatFields = [];
let joystickActive = false;
let movementVector = { x: 0, z: 0 };
let playerGroup;
let isPlayerOnGround = true;

// Planet parameters
const PLANET_RADIUS = 30;

// Initialize Game
function initGame() {
    console.log("Initializing game...");
    
    // Create scene
    scene = new THREE.Scene();
    
    // Set black background
    scene.background = new THREE.Color(0x000000);
    
    // Create renderer
    const canvas = document.getElementById('gameCanvas');
    renderer = new THREE.WebGLRenderer({ 
        canvas: canvas,
        antialias: true,
        powerPreference: 'default'
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    // Create camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    // Create player group
    playerGroup = new THREE.Group();
    scene.add(playerGroup);
    
    // Set up simple lighting FIRST
    setupBasicLighting();
    
    // Create the planet
    createBasicPlanet();
    
    // Create atmosphere
    createBasicAtmosphere();
    
    // Create stars
    createBasicStars();
    
    // Position camera
    camera.position.set(0, 5, -10);
    playerGroup.add(camera);
    
    // Create simple player
    const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
    const playerMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
    const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
    playerMesh.position.set(0, -1, 0);
    playerGroup.add(playerMesh);
    
    // Position player on planet
    positionPlayer();
    
    // Create some resources
    createBasicResources();
    
    // Setup controls
    setupMobileControls();
    
    // Setup UI
    setupUI();
    
    // Start animation
    animate();
    
    // Show welcome message
    setTimeout(() => {
        showNotification("Welcome to Planet Empire!");
    }, 1000);
}

// Basic lighting setup
function setupBasicLighting() {
    // Main light
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 10, 10);
    scene.add(light);
    
    // Ambient light
    const ambient = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(ambient);
    
    // Add a second light
    const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
    light2.position.set(-10, 5, -10);
    scene.add(light2);
}

// Create basic planet
function createBasicPlanet() {
    const geometry = new THREE.SphereGeometry(PLANET_RADIUS, 32, 32);
    
    // Create green planet material
    const material = new THREE.MeshPhongMaterial({
        color: 0x228B22, // Green
        shininess: 30,
        specular: 0x111111
    });
    
    planet = new THREE.Mesh(geometry, material);
    scene.add(planet);
}

// Create basic atmosphere
function createBasicAtmosphere() {
    const geometry = new THREE.SphereGeometry(PLANET_RADIUS * 1.05, 32, 32);
    const material = new THREE.MeshBasicMaterial({
        color: 0x87CEEB,
        transparent: true,
        opacity: 0.1,
        side: THREE.BackSide
    });
    
    const atmosphere = new THREE.Mesh(geometry, material);
    scene.add(atmosphere);
}

// Create basic stars
function createBasicStars() {
    const starsGeometry = new THREE.BufferGeometry();
    const starsCount = 1000;
    const positions = new Float32Array(starsCount * 3);
    
    for (let i = 0; i < starsCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 2000;
        positions[i + 1] = (Math.random() - 0.5) * 2000;
        positions[i + 2] = (Math.random() - 0.5) * 2000;
    }
    
    starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const starsMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1,
        sizeAttenuation: false
    });
    
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);
}

// Position player
function positionPlayer() {
    playerGroup.position.set(0, PLANET_RADIUS + 2, 0);
    gameState.player.position.copy(playerGroup.position);
}

// Create basic resources
function createBasicResources() {
    // Create some trees
    for (let i = 0; i < 15; i++) {
        createBasicTree();
    }
    
    // Create some rocks
    for (let i = 0; i < 10; i++) {
        createBasicRock();
    }
    
    // Create some wheat
    for (let i = 0; i < 8; i++) {
        createBasicWheat();
    }
}

function createBasicTree() {
    const angle = Math.random() * Math.PI * 2;
    const distance = PLANET_RADIUS + 2;
    const x = Math.cos(angle) * distance;
    const y = Math.sin(angle) * distance;
    
    const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
    const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
    
    const leavesGeometry = new THREE.SphereGeometry(1.5, 8, 8);
    const leavesMaterial = new THREE.MeshPhongMaterial({ color: 0x2E7D32 });
    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
    leaves.position.y = 2;
    
    const tree = new THREE.Group();
    tree.add(trunk);
    tree.add(leaves);
    
    tree.position.set(x, y, 0);
    tree.rotation.z = -angle;
    
    tree.userData = {
        type: 'tree',
        health: 3,
        woodYield: 5 + Math.floor(Math.random() * 5)
    };
    
    scene.add(tree);
    trees.push(tree);
}

function createBasicRock() {
    const angle = Math.random() * Math.PI * 2;
    const distance = PLANET_RADIUS + 1;
    const x = Math.cos(angle) * distance;
    const y = Math.sin(angle) * distance;
    
    const rockGeometry = new THREE.BoxGeometry(1, 1, 1);
    const rockMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
    
    rock.position.set(x, y, 0);
    rock.rotation.z = -angle;
    rock.rotation.x = Math.random() * Math.PI;
    rock.rotation.y = Math.random() * Math.PI;
    
    rock.userData = {
        type: 'rock',
        health: 5,
        stoneYield: 3 + Math.floor(Math.random() * 3),
        hasGold: Math.random() < 0.2
    };
    
    scene.add(rock);
    rocks.push(rock);
}

function createBasicWheat() {
    const angle = Math.random() * Math.PI * 2;
    const distance = PLANET_RADIUS + 1.5;
    const x = Math.cos(angle) * distance;
    const y = Math.sin(angle) * distance;
    
    const wheatGroup = new THREE.Group();
    const wheatCount = 5 + Math.floor(Math.random() * 8);
    
    for (let i = 0; i < wheatCount; i++) {
        const wheatGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 4);
        const wheatMaterial = new THREE.MeshPhongMaterial({ color: 0xDAA520 });
        const wheat = new THREE.Mesh(wheatGeometry, wheatMaterial);
        
        wheat.position.set(
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2,
            0
        );
        
        wheatGroup.add(wheat);
    }
    
    wheatGroup.position.set(x, y, 0);
    wheatGroup.rotation.z = -angle;
    
    wheatGroup.userData = {
        type: 'wheat',
        wheatYield: wheatCount
    };
    
    scene.add(wheatGroup);
    wheatFields.push(wheatGroup);
}

// Setup Mobile Controls
function setupMobileControls() {
    // Joystick
    const joystickArea = document.getElementById('joystickArea');
    const joystickHandle = document.getElementById('joystickHandle');
    const joystickRadius = 70;
    
    joystickArea.addEventListener('touchstart', handleJoystickStart);
    joystickArea.addEventListener('touchmove', handleJoystickMove);
    joystickArea.addEventListener('touchend', handleJoystickEnd);
    
    function handleJoystickStart(e) {
        e.preventDefault();
        joystickActive = true;
        updateJoystick(e.touches[0]);
    }
    
    function handleJoystickMove(e) {
        if (!joystickActive) return;
        e.preventDefault();
        updateJoystick(e.touches[0]);
    }
    
    function handleJoystickEnd(e) {
        e.preventDefault();
        joystickActive = false;
        movementVector.x = 0;
        movementVector.z = 0;
        joystickHandle.style.transform = 'translate(0, 0)';
    }
    
    function updateJoystick(touch) {
        const rect = joystickArea.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        let joystickX = touch.clientX - centerX;
        let joystickY = touch.clientY - centerY;
        
        const distance = Math.sqrt(joystickX * joystickX + joystickY * joystickY);
        if (distance > joystickRadius) {
            joystickX = (joystickX / distance) * joystickRadius;
            joystickY = (joystickY / distance) * joystickRadius;
        }
        
        joystickHandle.style.transform = `translate(${joystickX}px, ${joystickY}px)`;
        
        movementVector.x = joystickX / joystickRadius;
        movementVector.z = joystickY / joystickRadius;
    }
    
    // Touch to look
    let touchLookActive = false;
    let lastTouchX = 0, lastTouchY = 0;
    
    document.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        
        if (!target.closest('#joystickArea') && 
            !target.closest('.action-button') && 
            !target.closest('.tool') && 
            !target.closest('.quick-action')) {
            
            touchLookActive = true;
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
            e.preventDefault();
        }
    });
    
    document.addEventListener('touchmove', (e) => {
        if (!touchLookActive) return;
        
        const touch = e.touches[0];
        const deltaX = touch.clientX - lastTouchX;
        const deltaY = touch.clientY - lastTouchY;
        
        playerGroup.rotation.y -= deltaX * 0.01;
        camera.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, camera.rotation.x - deltaY * 0.005));
        
        lastTouchX = touch.clientX;
        lastTouchY = touch.clientY;
        e.preventDefault();
    });
    
    document.addEventListener('touchend', () => {
        touchLookActive = false;
    });
}

// Setup UI
function setupUI() {
    // Tool selection
    document.querySelectorAll('.tool').forEach(tool => {
        tool.addEventListener('click', () => {
            document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
            tool.classList.add('active');
            gameState.currentTool = tool.dataset.tool;
            
            const actionButton = document.getElementById('actionButton');
            switch(gameState.currentTool) {
                case 'axe': actionButton.textContent = 'ü™ì'; break;
                case 'pickaxe': actionButton.textContent = '‚õèÔ∏è'; break;
                case 'sickle': actionButton.textContent = 'üî™'; break;
                case 'hammer': actionButton.textContent = 'üî®'; break;
            }
            
            showNotification(`${tool.dataset.tool.toUpperCase()} selected`);
        });
    });
    
    // Action button
    document.getElementById('actionButton').addEventListener('click', () => {
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        
        const intersects = raycaster.intersectObjects([...trees, ...rocks, ...wheatFields], true);
        
        if (intersects.length > 0) {
            const object = intersects[0].object.parent || intersects[0].object;
            
            switch(gameState.currentTool) {
                case 'axe':
                    if (object.userData.type === 'tree') chopTree(object);
                    else showNotification('ü™ì Can only chop trees!');
                    break;
                case 'pickaxe':
                    if (object.userData.type === 'rock') mineRock(object);
                    else showNotification('‚õèÔ∏è Can only mine rocks!');
                    break;
                case 'sickle':
                    if (object.userData.type === 'wheat') harvestWheat(object);
                    else showNotification('üî™ Can only harvest wheat!');
                    break;
                case 'hammer':
                    showNotification('üî® Select a building from the menu!');
                    break;
            }
        } else {
            showNotification('‚ùå Nothing to interact with');
        }
    });
    
    // Jump button
    document.getElementById('jumpButton').addEventListener('click', () => {
        if (isPlayerOnGround) {
            isPlayerOnGround = false;
            playerGroup.position.y += 1;
            setTimeout(() => {
                playerGroup.position.y -= 1;
                isPlayerOnGround = true;
            }, 300);
        }
    });
    
    // Quick action buttons
    document.getElementById('mineButton').addEventListener('click', () => {
        gameState.currentTool = 'pickaxe';
        document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
        document.querySelector('.tool[data-tool="pickaxe"]').classList.add('active');
    });
    
    document.getElementById('buildButton').addEventListener('click', () => {
        document.getElementById('buildingMenu').style.display = 'flex';
    });
    
    document.getElementById('breadButton').addEventListener('click', () => {
        if (gameState.resources.bread > 0) {
            gameState.player.health = Math.min(100, gameState.player.health + 10);
            gameState.resources.bread--;
            updateResourceDisplay();
            showNotification('üçû Bread consumed! +10 Health');
        } else {
            showNotification('‚ùå Not enough bread!');
        }
    });
    
    // Building menu
    document.getElementById('closeMenu').addEventListener('click', () => {
        document.getElementById('buildingMenu').style.display = 'none';
    });
    
    document.querySelectorAll('.building-option').forEach(building => {
        building.addEventListener('click', () => {
            const buildingType = building.dataset.building;
            
            let cost, name;
            switch(buildingType) {
                case 'house': cost = { wood: 50, stone: 20 }; name = "House"; break;
                case 'farm': cost = { wood: 30, stone: 10 }; name = "Farm"; break;
                case 'mine': cost = { wood: 40, stone: 30 }; name = "Mine"; break;
                case 'bakery': cost = { wood: 60, stone: 40 }; name = "Bakery"; break;
            }
            
            if (gameState.resources.wood >= cost.wood && gameState.resources.stone >= cost.stone) {
                gameState.resources.wood -= cost.wood;
                gameState.resources.stone -= cost.stone;
                
                const buildingMesh = createBuilding(buildingType);
                scene.add(buildingMesh);
                gameState.buildings.push(buildingMesh);
                
                showNotification(`üè† ${name} built!`);
                updateResourceDisplay();
                document.getElementById('buildingMenu').style.display = 'none';
            } else {
                showNotification(`‚ùå Need ${cost.wood} Wood and ${cost.stone} Stone`);
            }
        });
    });
    
    // Window resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

// Resource functions
function chopTree(tree) {
    if (tree.userData.health > 0) {
        tree.userData.health--;
        showNotification(`ü™ì Chopping... ${tree.userData.health} hits left`);
        
        if (tree.userData.health <= 0) {
            gameState.resources.wood += tree.userData.woodYield;
            updateResourceDisplay();
            showNotification(`üå≥ +${tree.userData.woodYield} Wood`);
            
            scene.remove(tree);
            trees = trees.filter(t => t !== tree);
            
            setTimeout(createBasicTree, 10000);
        }
    }
}

function mineRock(rock) {
    if (rock.userData.health > 0) {
        rock.userData.health--;
        showNotification(`‚õèÔ∏è Mining... ${rock.userData.health} hits left`);
        
        if (rock.userData.health <= 0) {
            gameState.resources.stone += rock.userData.stoneYield;
            if (rock.userData.hasGold) {
                gameState.resources.gold += Math.floor(Math.random() * 3) + 1;
                showNotification(`üí∞ Found gold! +${rock.userData.stoneYield} Stone, +Gold!`);
            } else {
                showNotification(`ü™® +${rock.userData.stoneYield} Stone`);
            }
            updateResourceDisplay();
            
            scene.remove(rock);
            rocks = rocks.filter(r => r !== rock);
            
            setTimeout(createBasicRock, 15000);
        }
    }
}

function harvestWheat(wheatField) {
    const yieldAmount = wheatField.userData.wheatYield;
    gameState.resources.wheat += yieldAmount;
    updateResourceDisplay();
    showNotification(`üåæ +${yieldAmount} Wheat`);
    
    scene.remove(wheatField);
    wheatFields = wheatFields.filter(w => w !== wheatField);
    
    setTimeout(createBasicWheat, 8000);
}

function createBuilding(type) {
    let geometry, color;
    
    switch(type) {
        case 'house':
            geometry = new THREE.BoxGeometry(2, 2, 2);
            color = 0xD2691E;
            break;
        case 'farm':
            geometry = new THREE.BoxGeometry(3, 1, 3);
            color = 0x8BC34A;
            break;
        case 'mine':
            geometry = new THREE.ConeGeometry(1.5, 2, 4);
            color = 0x607D8B;
            break;
        case 'bakery':
            geometry = new THREE.BoxGeometry(2, 2, 2);
            color = 0xFF9800;
            break;
    }
    
    const material = new THREE.MeshPhongMaterial({ color: color });
    const building = new THREE.Mesh(geometry, material);
    
    // Position in front of player
    const angle = Math.atan2(playerGroup.position.y, playerGroup.position.x);
    const distance = PLANET_RADIUS + 3;
    building.position.set(
        Math.cos(angle) * distance,
        Math.sin(angle) * distance,
        0
    );
    
    building.rotation.z = -angle;
    
    return building;
}

// Update resource display
function updateResourceDisplay() {
    document.getElementById('woodCount').textContent = gameState.resources.wood;
    document.getElementById('wheatCount').textContent = gameState.resources.wheat;
    document.getElementById('stoneCount').textContent = gameState.resources.stone;
    document.getElementById('goldCount').textContent = gameState.resources.gold;
    document.getElementById('breadCount').textContent = gameState.resources.bread;
    document.getElementById('healthCount').textContent = gameState.player.health;
}

// Show notification
function showNotification(message) {
    const notification = document.createElement('div');
    notification.className = 'notification';
    notification.textContent = message;
    notification.style.borderColor = '#00ffff';
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.remove();
    }, 3000);
}

// Game loop
function animate() {
    requestAnimationFrame(animate);
    
    // Move player
    if (joystickActive) {
        const speed = 0.1;
        const angle = Math.atan2(playerGroup.position.y, playerGroup.position.x);
        
        // Move around the circle
        const newAngle = angle + movementVector.x * speed;
        const distance = Math.sqrt(playerGroup.position.x * playerGroup.position.x + 
                                 playerGroup.position.y * playerGroup.position.y);
        
        playerGroup.position.x = Math.cos(newAngle) * distance;
        playerGroup.position.y = Math.sin(newAngle) * distance;
        
        // Update rotation to face direction
        playerGroup.rotation.z = -newAngle;
    }
    
    // Rotate planet slowly
    planet.rotation.z += 0.001;
    
    // Make resources rotate with planet
    trees.forEach(tree => tree.rotation.z = -planet.rotation.z);
    rocks.forEach(rock => rock.rotation.z = -planet.rotation.z);
    wheatFields.forEach(wheat => wheat.rotation.z = -planet.rotation.z);
    
    // Render
    renderer.render(scene, camera);
}

// Start game
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGame);
} else {
    initGame();
}
    </script>
